using Definit.Results.NewApproach;

[assembly: GenerateEither.Base(3)]

namespace Definit.Results.NewApproach;

[System.AttributeUsage(System.AttributeTargets.Struct, AllowMultiple = false)]
public sealed class GenerateEitherAttribute : Attribute;

public static class GenerateEither
{
    [System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple = false)]
    internal sealed class BaseAttribute : Attribute
    {
        public int MaxCount { get; }

        public BaseAttribute(int maxCount)
        {
            MaxCount = maxCount;
        }
    }
}

public interface IEitherBase;

public interface IEitherBase<TValue> : IEitherBase
    where TValue : struct
{
    public TValue Value { get; }
}

//AutoGenerated
public interface IEither<T0, T1> : IEitherBase<(Or<T0>?, Or<T1>?)>
    where T0 : notnull
    where T1 : notnull;

public readonly struct Either<T0, T1> : IEither<T0, T1>
    where T0 : notnull
    where T1 : notnull
{
    public (Or<T0>?, Or<T1>?) Value { get; }

    [Obsolete(DefaultConstructorException.Attribute, true)]
    public Either() => throw new DefaultConstructorException();

    public Either(T0 value) => Value = (value, null);
    public Either(T1 value) => Value = (null, value);
    public Either(Either<T1, T0> value) => Value = (value.Value.Item2, value.Value.Item1);

    public static implicit operator Either<T0, T1>(T0 value) => new (value);
    public static implicit operator Either<T0, T1>(T1 value) => new (value);
    public static implicit operator Either<T0, T1>(Either<T1, T0> value) => new (value);
}

public static partial class EitherExtensions
{
    public static void Deconstruct<T0, T1>(this Either<T0, T1> result, out T0? t0, out T1? t1)
        where T0 : struct
        where T1 : struct 
    {
        (t0, t1) = result.Value;
    }
    
    public static void Deconstruct<T0, T1>(this Either<T0, T1> result, out IsNull<T0>? t0, out IsNull<T1>? t1)
        where T0 : class
        where T1 : class 
    {
        var (t_0, t_1) = result.Value;
         
        t0 = t_0.IsNull(); 
        t1 = t_1.IsNull(); 
    }

    public static void Deconstruct<T0, T1>(this Either<T0, T1> result, out T0? t0, out IsNull<T1>? t1)
        where T0 : struct
        where T1 : class 
    {
        (t0, var t_1) = result.Value;
        t1 = t_1.IsNull(); 
    }

    public static void Deconstruct<T0, T1>(this Either<T0, T1> result, out IsNull<T0>? t0, out T1? t1)
        where T0 : class
        where T1 : struct
    {
        (var t_0, t1) = result.Value;
        t0 = t_0.IsNull(); 
    }
}
